みなさんこんばんは、上手くいっていれば僕は #yidev の懇親会で中華を食べ終わってコーヒー☕でも飲みながらタイムラインを眺めているはずです。コーヒー飲みながら登壇するのは初めてです。自己紹介はプロフィールを見てくださいね。今日はSwift4の話をします。 #swtws

![001](twitter:852037368592818176)

---

Swift4に関しては、Swift.orgやswift-evolutionで毎日情報が流れていますが、僕自身ちゃんとキャッチアップできていませんでした。今日は出来るだけリソースを提示しながらお話したいと思います。 #swtws

---

内容を取り違えているかもしれないので、遠慮なくご指摘いただければ幸いです。僕が議題を提供し、みなさんと議論できればと思います。さて、早速始めましょう。Swift4が何を目指しているのかはここに記載されています。https://goo.gl/5XSu7M #swtws

---

Swift4は今年2017年の下期のリリースを目標に開発が進んでいます。Swift4には２つ目標があります。一つはSwift3のソースコードの安定性の提供、もう一つは、標準ライブラリのABI安定性の提供です。この２つの目標達成のために、開発を2段階に分けています。 #swtws

![002](twitter:852037374796111872)

---

Stage1: ソー​​ス安定性とABI安定性に必要なことにフォーカスしています。既存の言語機能のABIを根本的に変更しない機能や、標準ライブラリに対するAPIの破壊的な変更を意味する変更は、この段階では考慮していません。Stage1の主だった変更をご紹介します。 #swtws

![003](twitter:852037381674868737)

---

ソースの安定化：異なるSwiftの言語バージョンが同じソースコードに共存できます。Swift3.1ですでに@ available にSwiftのバージョン指定ができるようになっています。https://goo.gl/ZXcAhi #swtws

![005](twitter:852037390034100224)

---

ABIの安定化：コード生成に関して、Swiftランタイムとのやりとりを含めた改善です。SwiftのパフォーマンスやSwiftの今後の方向性に影響することがあります(詳細は後述)。 #swtws

---

ジェネリクスの改善：条件付き適合、再帰的なプロトコルの適合、Where節を使った条件付き関連型など、ジェネリクスの機能が強化されます。Genericsに関するプロポーサルを紹介します。ここにも記載されています。https://goo.gl/BPnfmK #swtws

---

[SE-0142]関連型が適合するプロトコルにwhere節で条件を付けることができます。 #swtws

![007](twitter:852037400779833345)

---

[SE-0143]条件付き適合(Conditional Confermance):
特定の条件にマッチしたときだけ、ジェネリクスをそのプロトコルに適合するようにできます。 #swtws

![008](twitter:852037412582588416)

---

[SE-0157]あるプロトコルの関連型がプロトコル自身に適合できるようになります。例では、先程のwhereを使って条件をつけています。 #swtws

![009](twitter:852037422892240896)

---

[SE-0148]subscriptに型変数が使えるようになりました。 #swtws

![010](twitter:852037431591292928)

---

[SE-0104]Genericsの改善とは直接関係しませんが、整数型をプロトコルで再構成して、Generic Programingできるようにします。現在だとこのようにIntとInt8でOperatorの適応はできません。 #swtws

![011](twitter:852037439241637892)

---

このようなプロトコルで再構成して、Generic Programingを可能にします。各プロトコルの詳細はこちらをご覧ください。
https://github.com/apple/swift-evolution/blob/master/proposals/0104-improved-integers.md #swtws

![012](twitter:852037449647652864)

---

Stringの再評価：Swift4では、Unicodeの正確さを維持しながら、よりパワフルで使いやすいStringにしようとしています。今日の後半でも少しStringのお話をします。 #swtws

---

Memory Ownership Model：CycloneやRustをインスパイアしたモデルになるそうです。Stage1にすべて導入するには巨大ですが、この段階で設計が必要とのことです。ですが具体的な話はまだ出てきていない認識です。 #swtws

---

以上がSwift4 Stage1における変更です。Stage 2に持ち越されるものもありますが、すべてSwift4で実現されるとうれしいですね！🚩。 #swtws

---

残念なことに、ABIの安定化は延期されました😇 2/16にその旨がメーリスに流れています。コンパイル時間の改善やコンパイラの安定化を優先したということです。https://goo.gl/3KBvrX #swtws

---

そもそも”ABIの安定化”とはどういうことでしょう。具体的には、ABI Manifestoに書かれています。簡単に言うと、違うバージョンのSwiftでコンパイルされたフレームワークをそのまま使えるぜ！ということです。https://goo.gl/PZd6j9 #swtws

---

Swiftのバージョンは統一する必要があるので、Carthageなどで導入したフレームワークは、現状ではVer.upの度にビルドし直す必要があります。ABIの安定化によって、Swiftのバージョンが先に進んでも、古いバージョンのフレームワークはそのまま使えます。 #swtws

---

このままSwift4がリリースされても、先述のソース安定化によって、同じソースコードにSwift3.xとSwift 4を同居させることは可能です。ですが、Carthageなどで導入しているライブラリがSwift4対応していない場合はどうなるでしょう。 #swtws

---

どんなに自分のソースコードをSwift4対応しても、フレームワークがSwift4でビルドされていなければコンパイルが通りません。OSS開発者のみなさま、ご対応よろしくお願いします🙏 #swtws

---

そのままSwift3を使い続けることもできます。Swift4がリリースされると、`-swift-version 3`と`-swift-version 4`の2つのフラグが提供されます。https://goo.gl/zwlT0Z #swtws

---

Swift Version 3モードは、Swift 4のコンパイラで、Swift3.1のソースコードのビルドが可能になるモードです。ところで今日お集まりのみなさんはSwift3への移行はお済ですよね？ #swtws

---

Swift Version 4は、Swift 4の破壊的変更を許容します。主に書き換えが必要なのは、String周辺です。Swift2.2からSwift3への変更に比べたらそんなに大したことないとのことですが、実際のところ試してみないとわかりません😇 #swtws

---

ちなみにStage2で何が変わるのかも見ておきましょう。Stage2ではABIの変更に影響を与えない程度の既存機能の変更が含まれます。 #swtws

![013](twitter:852037457356791808)

---

ソースの破壊的変更：Swift4モードの破壊的変更です。下記の方針で行われます。破壊的変更は続きますが、swift3モードがあるのでしばらくは大丈夫でしょうか。いつまで延命できるのか気になります。 #swtws

![014](twitter:852037467725221891)

---

既存の標準ライブラリの改善：コレクションアルゴリズムや、Dictionaryの改善などが含まれます。これに関連するものとして次のプロポーサルを見てみます。 #swtws

---

[SE-0154] Dictionaryのキーの探索と、mutatingが非効率なので、カスタムコレクションが提供されます。 #swtws

![016](twitter:852037479011991554)

---

現状ではLazyMapCollectionですが、keysもValueも独自のCollection型になります。 #swtws

![017](twitter:852037489384501250)

---

Foundationの改善：SwiftではCocoa SDKをシームレスに動作させるために、Foundation APIの改良する予定です。Stage2が開始されると、具体的な目標の詳細が記載されるとのことですが、今日までのところ、その内容は提示されていませんね… #swtws

---

以上がStage2の変更内容ですが、つまりまだ明確には定まっていませんし、予定より遅れ気味で進行しています。今まさに議論/開発がなされており、Swiftの成長が身近に感じられて楽しいですね。 #swtws

---

ここからは、Stringの再評価によって、どのようにAPIが変わるのか見てみましょう。これはString Manifestに記載されています。https://goo.gl/en9vg3 #swtws

---

Swift 4以降におけるStringが目指しているところは、Perlよりも優れていることらしいです🤔 それが実現するかはともかく、特に改善したいのは、人間工学(Ergonomics)、正確さ(Correctness)、パフォーマンスの３つです。 #swtws

---

Stringは標準ライブラリやFoundationによって複雑になっています。Stringだけで205個のAPIがあるようです。Intとの比較はジョークみたいなもんです 🤡 https://goo.gl/GW7dWp #swtws

---

APIをわかりやすくするために、以下の変更が加わります。 #swtws

![019](twitter:852037497898942465)

---

1.0では、Collectionでしたが、問題があって2.0で、そうではなくなりました。が、その問題も特に問題じゃなかったから復活させるそうです。とにかくSwift4では再びCollectionになります。https://goo.gl/YAXqyI #swtws

---

StringがCollectionになるということは、当然Sequenceにも適合しますので、mapやfilterも使えたりします。部分文字列にスライスすることもできます。 #swtws

---

スライス操作の統一：startとendが明確な場合、subscriptでスライスでき、in-place mutatingもサポートされます。特定のindexからstart/endまでのスライスはメソッドで行われ、in-place mutatingはされません。 #swtws

---

スライスすると、SubStringが生成されます。このSubStringの生成方法には3つの選択肢があり、3番を最良と考えているようです。https://goo.gl/dYMpfn #swtws

![020](twitter:852037504504954885)

---

現状では1です。。開始位置、長さ、バッファ所有者を持ったCharacterViewを生成します。効率の良さと引き換えに、Stringが開放されたあともSubStringが生き続けます。他言語ではメモリリークとみなされ、Java1.7からはコピーされます。 #swtws

![substring-1.png](twitter:852037511220125696)

---

3はStringとSubStringを別の型として扱います。欠点としては、Stringを作ると、SubStringも生成されることですが、SubStringはStringのサブタイプとなり、暗黙的型変換が使えるので、型が違うことも問題にならないと書いてあります。 #swtws

---

StringとSubStringは別の型という扱いになるので、Unicodeプロトコルの導入も検討されているようです。今日の段階で触れるにはもう少し仕様が変わりそうな気配がしたのでやめておきましょう。 #swtws

---

国際化の話です。まずlocalizedXXXというメソッドはなくなります。Localeはパラメータとして渡せるようになります。操作に応じて、デフォルトのオプションが変わります。 #swtws

![021](twitter:852037518778171392)

---

文字列操作に適応できるオプションはこのようになります。この国際化の話もSwift4ではまだ不完全で、Swift5でも議論が続くようですね。https://goo.gl/k7WfzH #swtws

![022](twitter:852037527703703556)

---

ここからは現時点でAcceptされたプロポーサル、実装済みのプロポーサルを見てみましょう。※SPM関係は今回除外します。また、Swift4で入るかは未定のものも多いです。プロポーサルのステータスはここから。https://goo.gl/Un6n1b #swtws

---

[SE-0110]タプルの表記について。現在は、タプルとして変数をクロージャで用いる場合も、その要素をそれぞれ変数として扱う場合も、引数に区別ありませんが、Swift4から関数型として宣言する場合は、二重括弧が必要となります。これはSwift4で入ります。 #swtws

![024](twitter:852037539456090113)

---

[SE-0042]Unapplied Method Referenceです。現在はcurry化されますが、Typeと引数を同じネストで引数となるように変更されます。 #swtws

![025](twitter:852037548910051328)

---

[SE-0075]Build Configuration Import Testの追加です。canImportでモジュール単位での判定が可能になります。今後OS単位のみでの判定のみでは難しくなるとの判断です。 #swtws

![026](twitter:852037562839334912)

---

[SE-0153]@NSCopyingの挙動についてです。NSCopyingに準拠したこのようなPersonクラスがあるとします。 #swtws

![027](twitter:852037576001114112)

---

現状では、@NSCopyingをつけても、initializerでコピーが起こりません。そのせいでディープコピーが起こらず予期せぬ挙動が起こることがあります。 #swtws

![028](twitter:852037592283402241)

---

期待した挙動を実現するには、現状ではinitializerで.copy()を明示的に呼ぶ必要があります。 #swtws

![029](twitter:852037611245887488)

---

これはわかりにくいので、@NSCopyingをつけると、常にコピーが起こるように修正されます。 #swtws

![030](twitter:852037620242587648)

---

[SE-0156]クラスとプロトコルを組み合わせて型を宣言することができます。クラス、サブクラス、プロトコルの組み合わせは5つのルールにもとづいて適用されます。 #swtws

![031](twitter:852037627943333891)

---

クラスであることはAnyObjectを使って示します。また、クラスとプロトコルを組み合わせることで、そのプロトコルに準拠したクラスのサブクラスであることを示します。 #swtws

![032](twitter:852037639658061824)

---

プロトコル構成にAnyObjectとClass両方が含まれる場合は、Classが優先されます。Classが2つ含まれる場合、そのクラスは同じ、またはサブクラスである必要があります。サブクラスの場合はスーパクラスをオーバーライドします。 #swtws

![033](twitter:852037653931335680)

---

プロトコル構成に含まれるtypealiasはプロトコル、クラス、AnyObjectに展開し、ルール1〜4を適応します。 #swtws

![034](twitter:852037668988780544)

---

[SE-0160]@objcの推論の挙動が変わります。簡単にまとめておくと、dynamicのついたもの、NSObject由来のクラスは従来は@objcをつけなくても@objcとして振る舞いましたが、swift4ではそうではなくなります。 #swtws

![035](twitter:852037684805615617)

---

プロポーサルにはとても詳しく書いてありますが、ツイートにまとめられなかったので、一昨日potatotipsで先に発表しておきました。資料：https://goo.gl/bZ2u9O #swtws

---

さて、今後のSwiftの変化を駆け巡ってみましたがいかがでしたでしょうか？今回登壇駆動でやってみましたが、内容が内容だけに結構きつかったです😇 ですが、今後Swiftがどんどん良い言語になっていくことを願ってやみません。以上です。どうもありがとうございました！ #swtws
